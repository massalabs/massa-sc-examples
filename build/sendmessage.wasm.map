{"version":3,"sources":["~lib/rt/common.ts","~lib/rt/tlsf.ts","~lib/shared/typeinfo.ts","~lib/rt/itcms.ts","assembly/sendmessage.m.ts","~lib/massa-sc-std/index.ts","~lib/util/error.ts","~lib/shared/runtime.ts","~lib/rt.ts","~lib/memory.ts","~lib/util/memory.ts"],"names":[],"mappings":"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","sourceRoot":"./sendmessage.wasm","sourcesContent":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n// @ts-ignore: decorator\n@inline export const TRACE = false;\n// @ts-ignore: decorator\n@inline export const RTRACE = isDefined(ASC_RTRACE);\n// @ts-ignore: decorator\n@inline export const PROFILE = isDefined(ASC_PROFILE);\n\n// Memory manager\n\n// ╒════════════ Memory manager block layout (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                           MM info                             │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize;\n}\n\n/** Overhead of a memory manager block. */\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD: usize = offsetof<BLOCK>();\n\n/** Maximum size of a memory manager block's payload. */\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n\n// Garbage collector\n\n// ╒══════════ Garbage collector object layout (32-bit) ═══════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                     Memory manager block                      │ -20\n// ╞═══════════════════════════════════════════════════════════════╡\n// │                            GC info                            │ -16\n// ├───────────────────────────────────────────────────────────────┤\n// │                            GC info                            │ -12\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT id                              │ -8\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT size                            │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class OBJECT extends BLOCK {\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Garbage collector info. */\n  gcInfo2: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n/** Overhead of a garbage collector object. Excludes memory manager block overhead. */\n// @ts-ignore: decorator\n@inline export const OBJECT_OVERHEAD: usize = (offsetof<OBJECT>() - BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK;\n\n/** Maximum size of a garbage collector object's payload. */\n// @ts-ignore: decorator\n@inline export const OBJECT_MAXSIZE: usize = BLOCK_MAXSIZE - OBJECT_OVERHEAD;\n\n/** Total of memory manager and garbage collector overhead. */\n// @ts-ignore: decorator\n@inline export const TOTAL_OVERHEAD: usize = BLOCK_OVERHEAD + OBJECT_OVERHEAD;\n","import { AL_BITS, AL_SIZE, AL_MASK, DEBUG, BLOCK, BLOCK_OVERHEAD, BLOCK_MAXSIZE } from \"./common\";\nimport { oninit, onalloc, onresize, onmove, onfree } from \"./rtrace\";\nimport { E_ALLOCATION_TOO_LARGE } from \"../util/error\";\n\n// === The TLSF (Two-Level Segregate Fit) memory allocator ===\n// see: http://www.gii.upv.es/tlsf/\n\n// - `ffs(x)` is equivalent to `ctz(x)` with x != 0\n// - `fls(x)` is equivalent to `sizeof(x) * 8 - clz(x) - 1`\n\n// ╒══════════════ Block size interpretation (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┴─┴─┴─╫─┴─┴─┴─┤\n// │ |                    FL                       │ SB = SL + AL  │ ◄─ usize\n// └───────────────────────────────────────────────┴───────╨───────┘\n// FL: first level, SL: second level, AL: alignment, SB: small block\n\n// @ts-ignore: decorator\n@inline const SL_BITS: u32 = 4;\n// @ts-ignore: decorator\n@inline const SL_SIZE: u32 = 1 << SL_BITS;\n\n// @ts-ignore: decorator\n@inline const SB_BITS: u32 = SL_BITS + AL_BITS;\n// @ts-ignore: decorator\n@inline const SB_SIZE: u32 = 1 << SB_BITS;\n\n// @ts-ignore: decorator\n@inline const FL_BITS: u32 = 31 - SB_BITS;\n\n// [00]: < 256B (SB)  [12]: < 1M\n// [01]: < 512B       [13]: < 2M\n// [02]: < 1K         [14]: < 4M\n// [03]: < 2K         [15]: < 8M\n// [04]: < 4K         [16]: < 16M\n// [05]: < 8K         [17]: < 32M\n// [06]: < 16K        [18]: < 64M\n// [07]: < 32K        [19]: < 128M\n// [08]: < 64K        [20]: < 256M\n// [09]: < 128K       [21]: < 512M\n// [10]: < 256K       [22]: <= 1G - OVERHEAD\n// [11]: < 512K\n// VMs limit to 2GB total (currently), making one 1G block max (or three 512M etc.) due to block overhead\n\n// Tags stored in otherwise unused alignment bits\n\n// @ts-ignore: decorator\n@inline const FREE: usize = 1 << 0;\n// @ts-ignore: decorator\n@inline const LEFTFREE: usize = 1 << 1;\n// @ts-ignore: decorator\n@inline const TAGS_MASK: usize = FREE | LEFTFREE; // <= AL_MASK\n\n// ╒════════════════════ Block layout (32-bit) ════════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┼─┤            ┐\n// │                          size                             │L│F│ ◄─┐ info   overhead\n// ╞>ptr═══════════════════════════════════════════════════════╧═╧═╡   │        ┘\n// │                        if free: ◄ prev                        │ ◄─┤ usize\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                        if free: next ►                        │ ◄─┤\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                             ...                               │   │ >= 0\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                        if free: back ▲                        │ ◄─┘\n// └───────────────────────────────────────────────────────────────┘ >= MIN SIZE\n// F: FREE, L: LEFTFREE\n@unmanaged export class Block extends BLOCK {\n\n  /** Previous free block, if any. Only valid if free, otherwise part of payload. */\n  prev: Block | null;\n  /** Next free block, if any. Only valid if free, otherwise part of payload. */\n  next: Block | null;\n\n  // If the block is free, there is a 'back'reference at its end pointing at its start.\n}\n\n// Block constants. A block must have a minimum size of three pointers so it can hold `prev`,\n// `next` and `back` if free.\n\n// @ts-ignore: decorator\n@inline const BLOCK_MINSIZE: usize = ((3 * sizeof<usize>() + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD; // prev + next + back\n// @ts-ignore: decorator\n// @inline const BLOCK_MAXSIZE: usize = 1 << (FL_BITS + SB_BITS - 1); // exclusive, lives in common.ts\n\n/** Gets the left block of a block. Only valid if the left block is free. */\n// @ts-ignore: decorator\n@inline function GETFREELEFT(block: Block): Block {\n  return load<Block>(changetype<usize>(block) - sizeof<usize>());\n}\n\n/** Gets the right block of a block by advancing to the right by its size. */\n// @ts-ignore: decorator\n@inline function GETRIGHT(block: Block): Block {\n  return changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + (block.mmInfo & ~TAGS_MASK));\n}\n\n// ╒═════════════════════ Root layout (32-bit) ════════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤          ┐\n// │        0        |           flMap                            S│ ◄────┐\n// ╞═══════════════════════════════════════════════════════════════╡      │\n// │                           slMap[0] S                          │ ◄─┐  │\n// ├───────────────────────────────────────────────────────────────┤   │  │\n// │                           slMap[1]                            │ ◄─┤  │\n// ├───────────────────────────────────────────────────────────────┤  u32 │\n// │                           slMap[22]                           │ ◄─┘  │\n// ╞═══════════════════════════════════════════════════════════════╡    usize\n// │                            head[0]                            │ ◄────┤\n// ├───────────────────────────────────────────────────────────────┤      │\n// │                              ...                              │ ◄────┤\n// ├───────────────────────────────────────────────────────────────┤      │\n// │                           head[367]                           │ ◄────┤\n// ╞═══════════════════════════════════════════════════════════════╡      │\n// │                             tail                              │ ◄────┘\n// └───────────────────────────────────────────────────────────────┘   SIZE   ┘\n// S: Small blocks map\n@unmanaged class Root {\n  /** First level bitmap. */\n  flMap: usize;\n}\n\n// Root constants. Where stuff is stored inside of the root structure.\n\n// @ts-ignore: decorator\n@inline const SL_START: usize = sizeof<usize>();\n// @ts-ignore: decorator\n@inline const SL_END: usize = SL_START + (FL_BITS << alignof<u32>());\n// @ts-ignore: decorator\n@inline const HL_START: usize = (SL_END + AL_MASK) & ~AL_MASK;\n// @ts-ignore: decorator\n@inline const HL_END: usize = HL_START + FL_BITS * SL_SIZE * sizeof<usize>();\n// @ts-ignore: decorator\n@inline const ROOT_SIZE: usize = HL_END + sizeof<usize>();\n\n// @ts-ignore: decorator\n@lazy export var ROOT: Root;\n\n/** Gets the second level map of the specified first level. */\n// @ts-ignore: decorator\n@inline function GETSL(root: Root, fl: usize): u32 {\n  return load<u32>(\n    changetype<usize>(root) + (fl << alignof<u32>()),\n    SL_START\n  );\n}\n\n/** Sets the second level map of the specified first level. */\n// @ts-ignore: decorator\n@inline function SETSL(root: Root, fl: usize, slMap: u32): void {\n  store<u32>(\n    changetype<usize>(root) + (fl << alignof<u32>()),\n    slMap,\n    SL_START\n  );\n}\n\n/** Gets the head of the free list for the specified combination of first and second level. */\n// @ts-ignore: decorator\n@inline function GETHEAD(root: Root, fl: usize, sl: u32): Block | null {\n  return load<Block>(\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\n    HL_START\n  );\n}\n\n/** Sets the head of the free list for the specified combination of first and second level. */\n// @ts-ignore: decorator\n@inline function SETHEAD(root: Root, fl: usize, sl: u32, head: Block | null): void {\n  store<Block | null>(\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\n    head,\n    HL_START\n  );\n}\n\n/** Gets the tail block.. */\n// @ts-ignore: decorator\n@inline function GETTAIL(root: Root): Block {\n  return load<Block>(\n    changetype<usize>(root),\n    HL_END\n  );\n}\n\n/** Sets the tail block. */\n// @ts-ignore: decorator\n@inline function SETTAIL(root: Root, tail: Block): void {\n  store<Block>(\n    changetype<usize>(root),\n    tail,\n    HL_END\n  );\n}\n\n/** Inserts a previously used block back into the free list. */\nfunction insertBlock(root: Root, block: Block): void {\n  if (DEBUG) assert(block); // cannot be null\n  var blockInfo = block.mmInfo;\n  if (DEBUG) assert(blockInfo & FREE); // must be free\n\n  var right = GETRIGHT(block);\n  var rightInfo = right.mmInfo;\n\n  // merge with right block if also free\n  if (rightInfo & FREE) {\n    removeBlock(root, right);\n    block.mmInfo = blockInfo = blockInfo + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK); // keep block tags\n    right = GETRIGHT(block);\n    rightInfo = right.mmInfo;\n    // 'back' is set below\n  }\n\n  // merge with left block if also free\n  if (blockInfo & LEFTFREE) {\n    let left = GETFREELEFT(block);\n    let leftInfo = left.mmInfo;\n    if (DEBUG) assert(leftInfo & FREE); // must be free according to right tags\n    removeBlock(root, left);\n    block = left;\n    block.mmInfo = blockInfo = leftInfo + BLOCK_OVERHEAD + (blockInfo & ~TAGS_MASK); // keep left tags\n    // 'back' is set below\n  }\n\n  right.mmInfo = rightInfo | LEFTFREE;\n  // reference to right is no longer used now, hence rightInfo is not synced\n\n  // we now know the size of the block\n  var size = blockInfo & ~TAGS_MASK;\n  if (DEBUG) assert(size >= BLOCK_MINSIZE); // must be a valid size\n  if (DEBUG) assert(changetype<usize>(block) + BLOCK_OVERHEAD + size == changetype<usize>(right)); // must match\n\n  // set 'back' to itself at the end of block\n  store<Block>(changetype<usize>(right) - sizeof<usize>(), block);\n\n  // mapping_insert\n  var fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    let boundedSize = min(size, BLOCK_MAXSIZE);\n    fl = inv - clz<usize>(boundedSize);\n    sl = <u32>((boundedSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // perform insertion\n  var head = GETHEAD(root, fl, sl);\n  block.prev = null;\n  block.next = head;\n  if (head) head.prev = block;\n  SETHEAD(root, fl, sl, block);\n\n  // update first and second level maps\n  root.flMap |= (1 << fl);\n  SETSL(root, fl, GETSL(root, fl) | (1 << sl));\n}\n\n/** Removes a free block from internal lists. */\nfunction removeBlock(root: Root, block: Block): void {\n  var blockInfo = block.mmInfo;\n  if (DEBUG) assert(blockInfo & FREE); // must be free\n  var size = blockInfo & ~TAGS_MASK;\n  if (DEBUG) assert(size >= BLOCK_MINSIZE); // must be valid\n\n  // mapping_insert\n  var fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    let boundedSize = min(size, BLOCK_MAXSIZE);\n    fl = inv - clz<usize>(boundedSize);\n    sl = <u32>((boundedSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // link previous and next free block\n  var prev = block.prev;\n  var next = block.next;\n  if (prev) prev.next = next;\n  if (next) next.prev = prev;\n\n  // update head if we are removing it\n  if (block == GETHEAD(root, fl, sl)) {\n    SETHEAD(root, fl, sl, next);\n\n    // clear second level map if head is empty now\n    if (!next) {\n      let slMap = GETSL(root, fl);\n      SETSL(root, fl, slMap &= ~(1 << sl));\n\n      // clear first level map if second level is empty now\n      if (!slMap) root.flMap &= ~(1 << fl);\n    }\n  }\n  // note: does not alter left/back because it is likely that splitting\n  // is performed afterwards, invalidating those changes. so, the caller\n  // must perform those updates.\n}\n\n/** Searches for a free block of at least the specified size. */\nfunction searchBlock(root: Root, size: usize): Block | null {\n  // size was already asserted by caller\n\n  // mapping_search\n  var fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const halfMaxSize = BLOCK_MAXSIZE >> 1; // don't round last fl\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    const invRound = inv - SL_BITS;\n    let requestSize = size < halfMaxSize\n      ? size + (1 << (invRound - clz<usize>(size))) - 1\n      : size;\n    fl = inv - clz<usize>(requestSize);\n    sl = <u32>((requestSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // search second level\n  var slMap = GETSL(root, fl) & (~0 << sl);\n  var head: Block | null = null;\n  if (!slMap) {\n    // search next larger first level\n    let flMap = root.flMap & (~0 << (fl + 1));\n    if (!flMap) {\n      head = null;\n    } else {\n      fl = ctz<usize>(flMap);\n      slMap = GETSL(root, fl);\n      if (DEBUG) assert(slMap);  // can't be zero if fl points here\n      head = GETHEAD(root, fl, ctz<u32>(slMap));\n    }\n  } else {\n    head = GETHEAD(root, fl, ctz<u32>(slMap));\n  }\n  return head;\n}\n\n/** Prepares the specified block before (re-)use, possibly splitting it. */\nfunction prepareBlock(root: Root, block: Block, size: usize): void {\n  // size was already asserted by caller\n\n  var blockInfo = block.mmInfo;\n  if (DEBUG) assert(!((size + BLOCK_OVERHEAD) & AL_MASK)); // size must be aligned so the new block is\n\n  // split if the block can hold another MINSIZE block incl. overhead\n  var remaining = (blockInfo & ~TAGS_MASK) - size;\n  if (remaining >= BLOCK_OVERHEAD + BLOCK_MINSIZE) {\n    block.mmInfo = size | (blockInfo & LEFTFREE); // also discards FREE\n\n    let spare = changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + size);\n    spare.mmInfo = (remaining - BLOCK_OVERHEAD) | FREE; // not LEFTFREE\n    insertBlock(root, spare); // also sets 'back'\n\n  // otherwise tag block as no longer FREE and right as no longer LEFTFREE\n  } else {\n    block.mmInfo = blockInfo & ~FREE;\n    GETRIGHT(block).mmInfo &= ~LEFTFREE;\n  }\n}\n\n/** Adds more memory to the pool. */\nfunction addMemory(root: Root, start: usize, end: usize): bool {\n  if (DEBUG) assert(start <= end); // must be valid\n  start = ((start + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\n  end &= ~AL_MASK;\n\n  var tail = GETTAIL(root);\n  var tailInfo: usize = 0;\n  if (tail) { // more memory\n    if (DEBUG) assert(start >= changetype<usize>(tail) + BLOCK_OVERHEAD);\n\n    // merge with current tail if adjacent\n    const offsetToTail = AL_SIZE;\n    if (start - offsetToTail == changetype<usize>(tail)) {\n      start -= offsetToTail;\n      tailInfo = tail.mmInfo;\n    } else {\n      // We don't do this, but a user might `memory.grow` manually\n      // leading to non-adjacent pages managed by TLSF.\n    }\n\n  } else if (DEBUG) { // first memory\n    assert(start >= changetype<usize>(root) + ROOT_SIZE); // starts after root\n  }\n\n  // check if size is large enough for a free block and the tail block\n  var size = end - start;\n  if (size < BLOCK_OVERHEAD + BLOCK_MINSIZE + BLOCK_OVERHEAD) {\n    return false;\n  }\n\n  // left size is total minus its own and the zero-length tail's header\n  var leftSize = size - 2 * BLOCK_OVERHEAD;\n  var left = changetype<Block>(start);\n  left.mmInfo = leftSize | FREE | (tailInfo & LEFTFREE);\n  left.prev = null;\n  left.next = null;\n\n  // tail is a zero-length used block\n  tail = changetype<Block>(start + BLOCK_OVERHEAD + leftSize);\n  tail.mmInfo = 0 | LEFTFREE;\n  SETTAIL(root, tail);\n\n  insertBlock(root, left); // also merges with free left before tail / sets 'back'\n\n  return true;\n}\n\n/** Grows memory to fit at least another block of the specified size. */\nfunction growMemory(root: Root, size: usize): void {\n  if (ASC_LOW_MEMORY_LIMIT) {\n    unreachable();\n    return;\n  }\n  // Here, both rounding performed in searchBlock ...\n  const halfMaxSize = BLOCK_MAXSIZE >> 1;\n  if (size < halfMaxSize) { // don't round last fl\n    const invRound = (sizeof<usize>() * 8 - 1) - SL_BITS;\n    size += (1 << (invRound - clz<usize>(size))) - 1;\n  }\n  // and additional BLOCK_OVERHEAD must be taken into account. If we are going\n  // to merge with the tail block, that's one time, otherwise it's two times.\n  var pagesBefore = memory.size();\n  size += BLOCK_OVERHEAD << usize((<usize>pagesBefore << 16) - BLOCK_OVERHEAD != changetype<usize>(GETTAIL(root)));\n  var pagesNeeded = <i32>(((size + 0xffff) & ~0xffff) >>> 16);\n  var pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n  if (memory.grow(pagesWanted) < 0) {\n    if (memory.grow(pagesNeeded) < 0) unreachable();\n  }\n  var pagesAfter = memory.size();\n  addMemory(root, <usize>pagesBefore << 16, <usize>pagesAfter << 16);\n}\n\n/** Computes the size (excl. header) of a block. */\nfunction computeSize(size: usize): usize {\n  // Size must be large enough and aligned minus preceeding overhead\n  return size <= BLOCK_MINSIZE\n    ? BLOCK_MINSIZE\n    : ((size + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\n}\n\n/** Prepares and checks an allocation size. */\nfunction prepareSize(size: usize): usize {\n  if (size > BLOCK_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  return computeSize(size);\n}\n\n/** Initializes the root structure. */\nfunction initialize(): void {\n  if (isDefined(ASC_RTRACE)) oninit(__heap_base);\n  var rootOffset = (__heap_base + AL_MASK) & ~AL_MASK;\n  var pagesBefore = memory.size();\n  var pagesNeeded = <i32>((((rootOffset + ROOT_SIZE) + 0xffff) & ~0xffff) >>> 16);\n  if (pagesNeeded > pagesBefore && memory.grow(pagesNeeded - pagesBefore) < 0) unreachable();\n  var root = changetype<Root>(rootOffset);\n  root.flMap = 0;\n  SETTAIL(root, changetype<Block>(0));\n  for (let fl: usize = 0; fl < FL_BITS; ++fl) {\n    SETSL(root, fl, 0);\n    for (let sl: u32 = 0; sl < SL_SIZE; ++sl) {\n      SETHEAD(root, fl, sl, null);\n    }\n  }\n  var memStart = rootOffset + ROOT_SIZE;\n  if (ASC_LOW_MEMORY_LIMIT) {\n    const memEnd = <usize>ASC_LOW_MEMORY_LIMIT & ~AL_MASK;\n    if (memStart <= memEnd) addMemory(root, memStart, memEnd);\n    else unreachable(); // low memory limit already exceeded\n  } else {\n    addMemory(root, memStart, memory.size() << 16);\n  }\n  ROOT = root;\n}\n\n/** Allocates a block of the specified size. */\nexport function allocateBlock(root: Root, size: usize): Block {\n  var payloadSize = prepareSize(size);\n  var block = searchBlock(root, payloadSize);\n  if (!block) {\n    growMemory(root, payloadSize);\n    block = changetype<Block>(searchBlock(root, payloadSize));\n    if (DEBUG) assert(block); // must be found now\n  }\n  if (DEBUG) assert((block.mmInfo & ~TAGS_MASK) >= payloadSize); // must fit\n  removeBlock(root, <Block>block);\n  prepareBlock(root, <Block>block, payloadSize);\n  if (isDefined(ASC_RTRACE)) onalloc(block);\n  return <Block>block;\n}\n\n/** Reallocates a block to the specified size. */\nexport function reallocateBlock(root: Root, block: Block, size: usize): Block {\n  var payloadSize = prepareSize(size);\n  var blockInfo = block.mmInfo;\n  var blockSize = blockInfo & ~TAGS_MASK;\n\n  // possibly split and update runtime size if it still fits\n  if (payloadSize <= blockSize) {\n    prepareBlock(root, block, payloadSize);\n    if (isDefined(ASC_RTRACE)) {\n      if (payloadSize != blockSize) onresize(block, BLOCK_OVERHEAD + blockSize);\n    }\n    return block;\n  }\n\n  // merge with right free block if merger is large enough\n  var right = GETRIGHT(block);\n  var rightInfo = right.mmInfo;\n  if (rightInfo & FREE) {\n    let mergeSize = blockSize + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK);\n    if (mergeSize >= payloadSize) {\n      removeBlock(root, right);\n      block.mmInfo = (blockInfo & TAGS_MASK) | mergeSize;\n      prepareBlock(root, block, payloadSize);\n      if (isDefined(ASC_RTRACE)) onresize(block, BLOCK_OVERHEAD + blockSize);\n      return block;\n    }\n  }\n\n  // otherwise move the block\n  return moveBlock(root, block, size);\n}\n\n/** Moves a block to a new one of the specified size. */\nfunction moveBlock(root: Root, block: Block, newSize: usize): Block {\n  var newBlock = allocateBlock(root, newSize);\n  memory.copy(changetype<usize>(newBlock) + BLOCK_OVERHEAD, changetype<usize>(block) + BLOCK_OVERHEAD, block.mmInfo & ~TAGS_MASK);\n  if (changetype<usize>(block) >= __heap_base) {\n    if (isDefined(ASC_RTRACE)) onmove(block, newBlock);\n    freeBlock(root, block);\n  }\n  return newBlock;\n}\n\n/** Frees a block. */\nexport function freeBlock(root: Root, block: Block): void {\n  if (isDefined(ASC_RTRACE)) onfree(block);\n  block.mmInfo = block.mmInfo | FREE;\n  insertBlock(root, block);\n}\n\n/** Checks that a used block is valid to be freed or reallocated. */\nfunction checkUsedBlock(ptr: usize): Block {\n  var block = changetype<Block>(ptr - BLOCK_OVERHEAD);\n  assert(\n    ptr != 0 && !(ptr & AL_MASK) &&  // must exist and be aligned\n    !(block.mmInfo & FREE)           // must be used\n  );\n  return block;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __alloc(size: usize): usize {\n  if (!ROOT) initialize();\n  return changetype<usize>(allocateBlock(ROOT, size)) + BLOCK_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __realloc(ptr: usize, size: usize): usize {\n  if (!ROOT) initialize();\n  return (ptr < __heap_base\n    ? changetype<usize>(moveBlock(ROOT, checkUsedBlock(ptr), size))\n    : changetype<usize>(reallocateBlock(ROOT, checkUsedBlock(ptr), size))\n  ) + BLOCK_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __free(ptr: usize): void {\n  if (ptr < __heap_base) return;\n  if (!ROOT) initialize();\n  freeBlock(ROOT, checkUsedBlock(ptr));\n}\n","// This file is shared with the compiler and must remain portable\n\n// ╒═══════════════════ Typeinfo interpretation ═══════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤ ◄─ __rtti_base\n// │                             count                             │\n// ╞═══════════════════════════════════════════════════════════════╡ ┐\n// │                      Typeinfo#flags [id=0]                    │ id < count\n// ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤\n// │                      Typeinfo#base  [id=0]                    │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              ...                              │\n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags = TypeinfoFlags.NONE;\n  /** Base class id or `0` if none. */\n  base: u32 = 0;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `StaticArray`. */\n  STATICARRAY = 1 << 2,\n  /** Type is a `Set`. */\n  SET = 1 << 3,\n  /** Type is a `Map`. */\n  MAP = 1 << 4,\n  /** Type has no outgoing pointers. */\n  POINTERFREE = 1 << 5,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 6,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 7,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 8,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 9,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 10,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 11,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 12,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 13,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 14,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 15,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 16,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 17,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 18,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 19,\n  /** Key is a signed type. */\n  KEY_SIGNED = 1 << 20,\n  /** Key is a float type. */\n  KEY_FLOAT = 1 << 21,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 22,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 23\n}\n","import { BLOCK, BLOCK_OVERHEAD, OBJECT_OVERHEAD, OBJECT_MAXSIZE, TOTAL_OVERHEAD, DEBUG, TRACE, RTRACE, PROFILE } from \"./common\";\nimport { onvisit, oncollect, oninterrupt, onyield } from \"./rtrace\";\nimport { TypeinfoFlags } from \"../shared/typeinfo\";\nimport { E_ALLOCATION_TOO_LARGE, E_ALREADY_PINNED, E_NOT_PINNED } from \"../util/error\";\n\n// === ITCMS: An incremental Tri-Color Mark & Sweep garbage collector ===\n// Adapted from Bach Le's μgc, see: https://github.com/bullno1/ugc\n\n// ╒═════════════╤══════════════ Colors ═══════════════════════════╕\n// │ Color       │ Meaning                                         │\n// ├─────────────┼─────────────────────────────────────────────────┤\n// │ WHITE*      │ Unprocessed                                     │\n// │ BLACK*      │ Processed                                       │\n// │ GRAY        │ Processed with unprocessed children             │\n// │ TRANSPARENT │ Manually pinned (always reachable)              │\n// └─────────────┴─────────────────────────────────────────────────┘\n// * flipped between cycles\n\n// @ts-ignore: decorator\n@lazy var white = 0;\n// @ts-ignore: decorator\n@inline const gray = 2;\n// @ts-ignore: decorator\n@inline const transparent = 3;\n// @ts-ignore: decorator\n@inline const COLOR_MASK = 3;\n\n/** Size in memory of all objects currently managed by the GC. */\n// @ts-ignore: decorator\n@lazy var total: usize = 0;\n\n/** Currently transitioning from SWEEP to MARK state. */\n// @ts-ignore: decorator\n@inline const STATE_IDLE = 0;\n/** Currently marking reachable objects. */\n// @ts-ignore: decorator\n@inline const STATE_MARK = 1;\n/** Currently sweeping unreachable objects. */\n// @ts-ignore: decorator\n@inline const STATE_SWEEP = 2;\n/** Current collector state. */\n// @ts-ignore: decorator\n@lazy var state = STATE_IDLE;\n\n// @ts-ignore: decorator\n@lazy var fromSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy var toSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy var pinSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy var iter: Object; // null\n\nfunction initLazy(space: Object): Object {\n  space.nextWithColor = changetype<usize>(space);\n  space.prev = space;\n  return space;\n}\n\n/** Visit cookie indicating scanning of an object. */\n// @ts-ignore: decorator\n@inline const VISIT_SCAN = 0;\n\n// ╒═══════════════ Managed object layout (32-bit) ════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                      Memory manager block                     │\n// ╞═══════════════════════════════════════════════════════════╤═══╡\n// │                              next                         │ C │ = nextWithColor\n// ├───────────────────────────────────────────────────────────┴───┤\n// │                              prev                             │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              rtId                             │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              rtSize                           │\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                               ...                             │\n// C: color\n\n/** Represents a managed object in memory, consisting of a header followed by the object's data. */\n@unmanaged class Object extends BLOCK {\n  /** Pointer to the next object with color flags stored in the alignment bits. */\n  nextWithColor: usize; // *u32\n  /** Pointer to the previous object. */\n  prev: Object; // *u32\n  /** Runtime id. */\n  rtId: u32;\n  /** Runtime size. */\n  rtSize: u32;\n\n  /** Gets the pointer to the next object. */\n  get next(): Object {\n    return changetype<Object>(this.nextWithColor & ~COLOR_MASK);\n  }\n\n  /** Sets the pointer to the next object. */\n  set next(obj: Object) {\n    this.nextWithColor = changetype<usize>(obj) | (this.nextWithColor & COLOR_MASK);\n  }\n\n  /** Gets this object's color. */\n  get color(): i32 {\n    return i32(this.nextWithColor & COLOR_MASK);\n  }\n\n  /** Sets this object's color. */\n  set color(color: i32) {\n    this.nextWithColor = (this.nextWithColor & ~COLOR_MASK) | color;\n  }\n\n  /** Gets the size of this object in memory. */\n  get size(): usize {\n    return BLOCK_OVERHEAD + (this.mmInfo & ~3);\n  }\n\n  /** Tests if this object is pointerfree. */\n  get isPointerfree(): bool {\n    var rtId = this.rtId;\n    return rtId <= idof<string>() || (__typeinfo(rtId) & TypeinfoFlags.POINTERFREE) != 0;\n  }\n\n  /** Unlinks this object from its list. */\n  unlink(): void {\n    var next = this.next;\n    if (next == null) {\n      if (DEBUG) assert(this.prev == null && changetype<usize>(this) < __heap_base);\n      return; // static data not yet linked\n    }\n    var prev = this.prev;\n    if (DEBUG) assert(prev);\n    next.prev = prev;\n    prev.next = next;\n  }\n\n  /** Links this object to the specified list, with the given color. */\n  linkTo(list: Object, withColor: i32): void {\n    let prev = list.prev;\n    this.nextWithColor = changetype<usize>(list) | withColor;\n    this.prev = prev;\n    prev.next = this;\n    list.prev = this;\n  }\n\n  /** Marks this object as gray, that is reachable with unscanned children. */\n  makeGray(): void {\n    if (this == iter) iter = assert(this.prev);\n    this.unlink();\n    this.linkTo(toSpace, this.isPointerfree ? i32(!white) : gray);\n  }\n}\n\n/** Visits all objects considered to be program roots. */\nfunction visitRoots(cookie: u32): void {\n  __visit_globals(cookie);\n  var pn = pinSpace;\n  var iter = pn.next;\n  while (iter != pn) {\n    if (DEBUG) assert(iter.color == transparent);\n    __visit_members(changetype<usize>(iter) + TOTAL_OVERHEAD, cookie);\n    iter = iter.next;\n  }\n}\n\n/** Visits all objects on the stack. */\nfunction visitStack(cookie: u32): void {\n  var ptr = __stack_pointer;\n  while (ptr < __heap_base) {\n    __visit(load<usize>(ptr), cookie);\n    ptr += sizeof<usize>();\n  }\n}\n\n/** Performs a single step according to the current state. */\nfunction step(): usize {\n  // Magic constants responsible for pause times. Obtained experimentally\n  // using the compiler compiling itself. 2048 budget pro run by default.\n  const MARKCOST = isDefined(ASC_GC_MARKCOST) ? ASC_GC_MARKCOST : 1;\n  const SWEEPCOST = isDefined(ASC_GC_SWEEPCOST) ? ASC_GC_SWEEPCOST : 10;\n  var obj: Object;\n  switch (state) {\n    case STATE_IDLE: {\n      state = STATE_MARK;\n      visitCount = 0;\n      visitRoots(VISIT_SCAN);\n      iter = toSpace;\n      return visitCount * MARKCOST;\n    }\n    case STATE_MARK: {\n      let black = i32(!white);\n      obj = iter.next;\n      while (obj != toSpace) {\n        iter = obj;\n        if (obj.color != black) { // skip already-blacks (pointerfree)\n          obj.color = black;\n          visitCount = 0;\n          __visit_members(changetype<usize>(obj) + TOTAL_OVERHEAD, VISIT_SCAN);\n          return visitCount * MARKCOST;\n        }\n        obj = obj.next;\n      }\n      visitCount = 0;\n      visitRoots(VISIT_SCAN);\n      obj = iter.next;\n      if (obj == toSpace) {\n        visitStack(VISIT_SCAN);\n        obj = iter.next;\n        while (obj != toSpace) {\n          if (obj.color != black) {\n            obj.color = black;\n            __visit_members(changetype<usize>(obj) + TOTAL_OVERHEAD, VISIT_SCAN);\n          }\n          obj = obj.next;\n        }\n        let from = fromSpace;\n        fromSpace = toSpace;\n        toSpace = from;\n        white = black;\n        iter = from.next;\n        state = STATE_SWEEP;\n      }\n      return visitCount * MARKCOST;\n    }\n    case STATE_SWEEP: {\n      obj = iter;\n      if (obj != toSpace) {\n        iter = obj.next;\n        if (DEBUG) assert(obj.color == i32(!white)); // old white\n        free(obj);\n        return SWEEPCOST;\n      }\n      toSpace.nextWithColor = changetype<usize>(toSpace);\n      toSpace.prev = toSpace;\n      state = STATE_IDLE;\n      break;\n    }\n  }\n  return 0;\n}\n\n/** Frees an object. */\nfunction free(obj: Object): void {\n  if (changetype<usize>(obj) < __heap_base) {\n    obj.nextWithColor = 0; // may become linked again\n    obj.prev = changetype<Object>(0);\n  } else {\n    total -= obj.size;\n    if (isDefined(__finalize)) {\n      __finalize(changetype<usize>(obj) + TOTAL_OVERHEAD);\n    }\n    __free(changetype<usize>(obj) + BLOCK_OVERHEAD);\n  }\n}\n\n// Garbage collector interface\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __new(size: usize, id: i32): usize {\n  if (size >= OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  if (total >= threshold) interrupt();\n  var obj = changetype<Object>(__alloc(OBJECT_OVERHEAD + size) - BLOCK_OVERHEAD);\n  obj.rtId = id;\n  obj.rtSize = <u32>size;\n  obj.linkTo(fromSpace, white); // inits next/prev\n  total += obj.size;\n  var ptr = changetype<usize>(obj) + TOTAL_OVERHEAD;\n  // may be visited before being fully initialized, so must fill\n  memory.fill(ptr, 0, size);\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __renew(oldPtr: usize, size: usize): usize {\n  var oldObj = changetype<Object>(oldPtr - TOTAL_OVERHEAD);\n  // Update object size if its block is large enough\n  if (size <= (oldObj.mmInfo & ~3) - OBJECT_OVERHEAD) {\n    oldObj.rtSize = <u32>size;\n    return oldPtr;\n  }\n  // If not the same object anymore, we have to move it move it due to the\n  // shadow stack potentially still referencing the old object\n  var newPtr = __new(size, oldObj.rtId);\n  memory.copy(newPtr, oldPtr, min(size, oldObj.rtSize));\n  return newPtr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void {\n  // Write barrier is unnecessary if non-incremental\n  if (!childPtr) return;\n  if (DEBUG) assert(parentPtr);\n  var child = changetype<Object>(childPtr - TOTAL_OVERHEAD);\n  if (child.color == white) {\n    let parent = changetype<Object>(parentPtr - TOTAL_OVERHEAD);\n    let parentColor = parent.color;\n    if (parentColor == i32(!white)) {\n      // Maintain the invariant that no black object may point to a white object.\n      if (expectMultiple) {\n        // Move the barrier \"backward\". Suitable for containers receiving multiple stores.\n        // Avoids a barrier for subsequent objects stored into the same container.\n        parent.makeGray();\n      } else {\n        // Move the barrier \"forward\". Suitable for objects receiving isolated stores.\n        child.makeGray();\n      }\n    } else if (parentColor == transparent && state == STATE_MARK) {\n      // Pinned objects are considered 'black' during the mark phase.\n      child.makeGray();\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@lazy var visitCount = 0;\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __visit(ptr: usize, cookie: i32): void {\n  if (!ptr) return;\n  let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n  if (RTRACE) if (!onvisit(obj)) return;\n  if (obj.color == white) {\n    obj.makeGray();\n    ++visitCount;\n  }\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __pin(ptr: usize): usize {\n  if (ptr) {\n    let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n    if (obj.color == transparent) {\n      throw new Error(E_ALREADY_PINNED);\n    }\n    obj.unlink(); // from fromSpace\n    obj.linkTo(pinSpace, transparent);\n  }\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __unpin(ptr: usize): void {\n  if (!ptr) return;\n  var obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n  if (obj.color != transparent) {\n    throw new Error(E_NOT_PINNED);\n  }\n  if (state == STATE_MARK) {\n    // We may be right at the point after marking roots for the second time and\n    // entering the sweep phase, in which case the object would be missed if it\n    // is not only pinned but also a root. Make sure it isn't missed.\n    obj.makeGray();\n  } else {\n    obj.unlink();\n    obj.linkTo(fromSpace, white);\n  }\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __collect(): void {\n  if (TRACE) trace(\"GC (full) at\", 1, total);\n  if (state > STATE_IDLE) {\n    // finish current cycle\n    while (state != STATE_IDLE) step();\n  }\n  // perform a full cycle\n  step();\n  while (state != STATE_IDLE) step();\n  threshold = <usize>(<u64>total * IDLEFACTOR / 100) + GRANULARITY;\n  if (TRACE) trace(\"GC (full) done at cur/max\", 2, total, memory.size() << 16);\n  if (RTRACE || PROFILE) oncollect(total);\n}\n\n// Garbage collector automation\n\n/** How often to interrupt. The default of 1024 means \"interrupt each 1024 bytes allocated\". */\n// @ts-ignore: decorator\n@inline const GRANULARITY: usize = isDefined(ASC_GC_GRANULARITY) ? ASC_GC_GRANULARITY : 1024;\n/** How long to interrupt. The default of 200% means \"run at double the speed of allocations\". */\n// @ts-ignore: decorator\n@inline const STEPFACTOR: usize = isDefined(ASC_GC_SWEEPFACTOR) ? ASC_GC_SWEEPFACTOR : 200;\n/** How long to idle. The default of 200% means \"wait for memory to double before kicking in again\". */\n// @ts-ignore: decorator\n@inline const IDLEFACTOR: usize = isDefined(ASC_GC_IDLEFACTOR) ? ASC_GC_IDLEFACTOR : 200;\n\n/** Threshold of memory used by objects to exceed before interrupting again. */\n// @ts-ignore: decorator\n@lazy var threshold: usize = ((<usize>memory.size() << 16) - __heap_base) >> 1;\n\n/** Performs a reasonable amount of incremental GC steps. */\nfunction interrupt(): void {\n  if (PROFILE) oninterrupt(total);\n  if (TRACE) trace(\"GC (auto) at\", 1, total);\n  var budget: isize = GRANULARITY * STEPFACTOR / 100;\n  do {\n    budget -= step();\n    if (state == STATE_IDLE) {\n      if (TRACE) trace(\"└ GC (auto) done at cur/max\", 2, total, memory.size() << 16);\n      threshold = <usize>(<u64>total * IDLEFACTOR / 100) + GRANULARITY;\n      if (PROFILE) onyield(total);\n      return;\n    }\n  } while (budget > 0);\n  if (TRACE) trace(\"└ GC (auto) ongoing at\", 1, total);\n  threshold = total + GRANULARITY * usize(total - threshold < GRANULARITY);\n  if (PROFILE) onyield(total);\n}\n","/** ***********************\n * Smart contract that pushes a SC containing a message handler\n * function and sends an asynchronous message to that same SC\n **/\n\nimport { send_message, print, create_sc, include_base64 } from \"massa-sc-std\"\n\nexport function main(name: string): void {\n    const bytes = \"AGFzbQEAAAABKQhgAX8AYAAAYAN/f38AYAJ/fwBgAn9/AX9gBH9/f38AYAABf2ABfwF/AisCA2VudgVhYm9ydAAFBW1hc3NhFWFzc2VtYmx5X3NjcmlwdF9wcmludAAAAxQTAQAAAwMCAQYEBAICBwABAAEAAAUDAQABBkAMfwFBAAt/AUEAC38BQQALfwFBAAt/AUEAC38BQQALfwFBAAt/AUEAC38BQQALfwFBAAt/AEGADQt/AUGcjQELB0gHBV9fbmV3AAsFX19waW4ADgdfX3VucGluAA8JX19jb2xsZWN0ABALX19ydHRpX2Jhc2UDCgZtZW1vcnkCAAdyZWNlaXZlABMIARIKjyoTXQECf0HAChAUQYAJEBRBkAwQFEHQDBAUIwQiASgCBEF8cSEAA0AgACABRwRAIAAoAgRBA3FBA0cEQEEAQcAJQZ8BQRAQAAALIABBFGoQESAAKAIEQXxxIQAMAQsLC2IBAX8gACgCBEF8cSIBRQRAQQAgAEGcjQFJIAAoAggbRQRAQQBBwAlB/wBBEhAAAAsPCyAAKAIIIgBFBEBBAEHACUGDAUEQEAAACyABIAA2AgggACAAKAIEQQNxIAFyNgIEC58BAQN/IwUgAEYEQCAAKAIIIgFFBEBBAEHACUGTAUEeEAAACyABJAULIAAQAyMGIQEgACgCDCICQQFNBH9BAQVBgA0oAgAgAkkEQEHACkGAC0EWQRwQAAALIAJBA3RBhA1qKAIAQSBxCyEDIAEoAgghAiAAIAEjB0VBAiADG3I2AgQgACACNgIIIAIgAigCBEEDcSAAcjYCBCABIAA2AggLlAIBBH8gASgCACICQQFxRQRAQQBB0AtBjAJBDhAAAAsgAkF8cSICQQxJBEBBAEHQC0GOAkEOEAAACyACQYACSQR/IAJBBHYFQR8gAkH8////AyACQfz///8DSRsiAmdrIgRBB2shAyACIARBBGt2QRBzCyICQRBJIANBF0lxRQRAQQBB0AtBnAJBDhAAAAsgASgCCCEFIAEoAgQiBARAIAQgBTYCCAsgBQRAIAUgBDYCBAsgAiADQQR0akECdCAAaigCYCABRgRAIAIgA0EEdGpBAnQgAGogBTYCYCAFRQRAIANBAnQgAGoiASgCBEF+IAJ3cSECIAEgAjYCBCACRQRAIAAgACgCAEF+IAN3cTYCAAsLCwvDAwEFfyABRQRAQQBB0AtByQFBDhAAAAsgASgCACIDQQFxRQRAQQBB0AtBywFBDhAAAAsgAUEEaiABKAIAQXxxaiIEKAIAIgJBAXEEQCAAIAQQBSABIANBBGogAkF8cWoiAzYCACABQQRqIAEoAgBBfHFqIgQoAgAhAgsgA0ECcQRAIAFBBGsoAgAiASgCACIGQQFxRQRAQQBB0AtB3QFBEBAAAAsgACABEAUgASAGQQRqIANBfHFqIgM2AgALIAQgAkECcjYCACADQXxxIgJBDEkEQEEAQdALQekBQQ4QAAALIAIgAUEEamogBEcEQEEAQdALQeoBQQ4QAAALIARBBGsgATYCACACQYACSQR/IAJBBHYFQR8gAkH8////AyACQfz///8DSRsiAmdrIgNBB2shBSACIANBBGt2QRBzCyICQRBJIAVBF0lxRQRAQQBB0AtB+wFBDhAAAAsgAiAFQQR0akECdCAAaigCYCEDIAFBADYCBCABIAM2AgggAwRAIAMgATYCBAsgAiAFQQR0akECdCAAaiABNgJgIAAgACgCAEEBIAV0cjYCACAFQQJ0IABqIgAgACgCBEEBIAJ0cjYCBAvNAQECfyABIAJLBEBBAEHQC0H5AkEOEAAACyABQRNqQXBxQQRrIQEgACgCoAwiBARAIAEgBEEEakkEQEEAQdALQYADQRAQAAALIAQgAUEQa0YEQCAEKAIAIQMgAUEQayEBCwUgASAAQaQMakkEQEEAQdALQY0DQQUQAAALCyACQXBxIAFrIgJBFEkEQA8LIAEgA0ECcSACQQhrIgJBAXJyNgIAIAFBADYCBCABQQA2AgggAiABQQRqaiICQQI2AgAgACACNgKgDCAAIAEQBguWAQECfz8AIgFBAEwEf0EBIAFrQABBAEgFQQALBEAAC0GgjQFBADYCAEHAmQFBADYCAANAIABBF0kEQCAAQQJ0QaCNAWpBADYCBEEAIQEDQCABQRBJBEAgASAAQQR0akECdEGgjQFqQQA2AmAgAUEBaiEBDAELCyAAQQFqIQAMAQsLQaCNAUHEmQE/AEEQdBAHQaCNASQJC/ADAQN/AkACQAJAAkAjAg4DAAECAwtBASQCQQAkAxACIwYkBSMDDwsjB0UhASMFKAIEQXxxIQADQCMGIABHBEAgACQFIAAoAgRBA3EgAUcEQCAAIAEgACgCBEF8cXI2AgRBACQDIABBFGoQESMDDwsgACgCBEF8cSEADAELC0EAJAMQAiMGIwUoAgRBfHFGBEAjCyEAA0AgAEGcjQFJBEAgACgCACICBEAgAhAUCyAAQQRqIQAMAQsLIwUoAgRBfHEhAANAIwYgAEcEQCAAKAIEQQNxIAFHBEAgACABIAAoAgRBfHFyNgIEIABBFGoQEQsgACgCBEF8cSEADAELCyMIIQAjBiQIIAAkBiABJAcgACgCBEF8cSQFQQIkAgsjAw8LIwUiACMGRwRAIAAoAgQiAUF8cSQFIwdFIAFBA3FHBEBBAEHACUHkAUEUEAAACyAAQZyNAUkEQCAAQQA2AgQgAEEANgIIBSMAIAAoAgBBfHFBBGprJAAgAEEEaiIAQZyNAU8EQCMJRQRAEAgLIwkhASAAQQRrIQIgAEEPcUEBIAAbBH9BAQUgAigCAEEBcQsEQEEAQdALQa8EQQMQAAALIAIgAigCAEEBcjYCACABIAIQBgsLQQoPCyMGIgAgADYCBCAAIAA2AghBACQCC0EAC9QBAQJ/IAFBgAJJBH8gAUEEdgVBH0EBQRsgAWdrdCABakEBayABIAFB/v///wFJGyIBZ2siA0EHayECIAEgA0EEa3ZBEHMLIgFBEEkgAkEXSXFFBEBBAEHQC0HKAkEOEAAACyACQQJ0IABqKAIEQX8gAXRxIgEEfyABaCACQQR0akECdCAAaigCYAUgACgCAEF/IAJBAWp0cSIBBH8gAWgiAUECdCAAaigCBCICRQRAQQBB0AtB1wJBEhAAAAsgAmggAUEEdGpBAnQgAGooAmAFQQALCwuBBwEFfyAAQez///8DTwRAQYAJQcAJQYQCQR8QAAALIwAjAU8EQAJAQYAQIQIDQCACEAlrIQIjAkUEQCMArULIAX5C5ACAp0GACGokAQwCCyACQQBKDQALIwAiAiACIwFrQYAISUEKdGokAQsLIwlFBEAQCAsjCSEFIABBEGoiAkH8////A0sEQEGACUHQC0HKA0EdEAAACyAFQQwgAkETakFwcUEEayACQQxNGyIDEAoiAkUEQD8AIgJBBCAFKAKgDCACQRB0QQRrR3RBAUEbIANna3RBAWsgA2ogAyADQf7///8BSRtqQf//A2pBgIB8cUEQdiIEIAIgBEobQABBAEgEQCAEQABBAEgEQAALCyAFIAJBEHQ/AEEQdBAHIAUgAxAKIgJFBEBBAEHQC0HwA0EQEAAACwsgAigCAEF8cSADSQRAQQBB0AtB8gNBDhAAAAsgBSACEAUgAigCACEGIANBBGpBD3EEQEEAQdALQeUCQQ4QAAALIAZBfHEgA2siBEEQTwRAIAIgBkECcSADcjYCACADIAJBBGpqIgMgBEEEa0EBcjYCACAFIAMQBgUgAiAGQX5xNgIAIAJBBGogAigCAEF8cWoiAyADKAIAQX1xNgIACyACIAE2AgwgAiAANgIQIwgiASgCCCEDIAIjByABcjYCBCACIAM2AgggAyADKAIEQQNxIAJyNgIEIAEgAjYCCCMAIAIoAgBBfHFBBGpqJAAgAkEUaiICIQECQCAARQ0AIAFBADoAACAAIAFqIgNBAWtBADoAACAAQQJNDQAgAUEAOgABIAFBADoAAiADQQJrQQA6AAAgA0EDa0EAOgAAIABBBk0NACABQQA6AAMgA0EEa0EAOgAAIABBCE0NACABQQAgAWtBA3EiA2oiAUEANgIAIAEgACADa0F8cSIAaiIDQQRrQQA2AgAgAEEITQ0AIAFBADYCBCABQQA2AgggA0EMa0EANgIAIANBCGtBADYCACAAQRhNDQAgAUEANgIMIAFBADYCECABQQA2AhQgAUEANgIYIANBHGtBADYCACADQRhrQQA2AgAgA0EUa0EANgIAIANBEGtBADYCACABIAFBBHFBGGoiA2ohASAAIANrIQADQCAAQSBPBEAgAUIANwMAIAFCADcDCCABQgA3AxAgAUIANwMYIABBIGshACABQSBqIQEMAQsLCyACC7sKAQN/A0AgAUEDcUEAIAIbBEAgACIDQQFqIQAgASIEQQFqIQEgAyAELQAAOgAAIAJBAWshAgwBCwsgAEEDcUUEQANAIAJBEE8EQCAAIAEoAgA2AgAgACABKAIENgIEIAAgASgCCDYCCCAAIAEoAgw2AgwgAUEQaiEBIABBEGohACACQRBrIQIMAQsLIAJBCHEEQCAAIAEoAgA2AgAgACABKAIENgIEIAFBCGohASAAQQhqIQALIAJBBHEEQCAAIAEoAgA2AgAgAUEEaiEBIABBBGohAAsgAkECcQRAIAAgAS8BADsBACABQQJqIQEgAEECaiEACyACQQFxBEAgACABLQAAOgAACw8LIAJBIE8EQAJAAkACQAJAIABBA3FBAWsOAwABAgMLIAEoAgAhBSAAIAEtAAA6AAAgACABLQABOgABIABBAmoiA0EBaiEAIAFBAmoiBEEBaiEBIAMgBC0AADoAACACQQNrIQIDQCACQRFPBEAgACABKAIBIgNBCHQgBUEYdnI2AgAgACABKAIFIgRBCHQgA0EYdnI2AgQgACABKAIJIgNBCHQgBEEYdnI2AgggACABKAINIgVBCHQgA0EYdnI2AgwgAUEQaiEBIABBEGohACACQRBrIQIMAQsLDAILIAEoAgAhBSAAIAEtAAA6AAAgACIDQQJqIQAgASIEQQJqIQEgAyAELQABOgABIAJBAmshAgNAIAJBEk8EQCAAIAEoAgIiA0EQdCAFQRB2cjYCACAAIAEoAgYiBEEQdCADQRB2cjYCBCAAIAEoAgoiA0EQdCAEQRB2cjYCCCAAIAEoAg4iBUEQdCADQRB2cjYCDCABQRBqIQEgAEEQaiEAIAJBEGshAgwBCwsMAQsgASgCACEFIAAiA0EBaiEAIAEiBEEBaiEBIAMgBC0AADoAACACQQFrIQIDQCACQRNPBEAgACABKAIDIgNBGHQgBUEIdnI2AgAgACABKAIHIgRBGHQgA0EIdnI2AgQgACABKAILIgNBGHQgBEEIdnI2AgggACABKAIPIgVBGHQgA0EIdnI2AgwgAUEQaiEBIABBEGohACACQRBrIQIMAQsLCwsgAkEQcQRAIAAgAS0AADoAACAAIAEtAAE6AAEgAEECaiIAIAFBAmoiAS0AADoAACAAIAEtAAE6AAEgAEECaiIAIAFBAmoiAS0AADoAACAAIAEtAAE6AAEgAEECaiIAIAFBAmoiAS0AADoAACAAIAEtAAE6AAEgAEECaiIAIAFBAmoiAS0AADoAACAAIAEtAAE6AAEgAEECaiIAIAFBAmoiAS0AADoAACAAIAEtAAE6AAEgAEECaiIAIAFBAmoiAS0AADoAACAAIAEtAAE6AAEgAEECaiIAIAFBAmoiAy0AADoAACADQQJqIQEgACADLQABOgABIABBAmohAAsgAkEIcQRAIAAgAS0AADoAACAAIAEtAAE6AAEgAEECaiIAIAFBAmoiAS0AADoAACAAIAEtAAE6AAEgAEECaiIAIAFBAmoiAS0AADoAACAAIAEtAAE6AAEgAEECaiIAIAFBAmoiAy0AADoAACADQQJqIQEgACADLQABOgABIABBAmohAAsgAkEEcQRAIAAgAS0AADoAACAAIAEtAAE6AAEgAEECaiIAIAFBAmoiAy0AADoAACADQQJqIQEgACADLQABOgABIABBAmohAAsgAkECcQRAIAAgAS0AADoAACAAIgNBAmohACABIgRBAmohASADIAQtAAE6AAELIAJBAXEEQCAAIAEtAAA6AAALC84CAQJ/AkAgAiEEIAAgAUYNACABIABrIARrQQAgBEEBdGtNBEAgACABIAQQDAwBCyAAIAFJBEAgAUEHcSAAQQdxRgRAA0AgAEEHcQRAIARFDQQgBEEBayEEIAAiAkEBaiEAIAEiA0EBaiEBIAIgAy0AADoAAAwBCwsDQCAEQQhPBEAgACABKQMANwMAIARBCGshBCAAQQhqIQAgAUEIaiEBDAELCwsDQCAEBEAgACICQQFqIQAgASIDQQFqIQEgAiADLQAAOgAAIARBAWshBAwBCwsFIAFBB3EgAEEHcUYEQANAIAAgBGpBB3EEQCAERQ0EIARBAWsiBCAAaiABIARqLQAAOgAADAELCwNAIARBCE8EQCAEQQhrIgQgAGogASAEaikDADcDAAwBCwsLA0AgBARAIARBAWsiBCAAaiABIARqLQAAOgAADAELCwsLC2EBA38gAARAIABBFGsiASgCBEEDcUEDRgRAQZAMQcAJQdECQQcQAAALIAEQAyMEIgMoAgghAiABIANBA3I2AgQgASACNgIIIAIgAigCBEEDcSABcjYCBCADIAE2AggLIAALbgECfyAARQRADwsgAEEUayIBKAIEQQNxQQNHBEBB0AxBwAlB3wJBBRAAAAsjAkEBRgRAIAEQBAUgARADIwgiACgCCCECIAEjByAAcjYCBCABIAI2AgggAiACKAIEQQNxIAFyNgIEIAAgATYCCAsLOQAjAkEASgRAA0AjAgRAEAkaDAELCwsQCRoDQCMCBEAQCRoMAQsLIwCtQsgBfkLkAICnQYAIaiQBCy4AAkACQAJAAkAgAEEIaygCAA4DAAECAwsPCw8LIAAoAgAiAARAIAAQFAsPCwALVgA/AEEQdEGcjQFrQQF2JAFB9AlB8Ak2AgBB+AlB8Ak2AgBB8AkkBEGUCkGQCjYCAEGYCkGQCjYCAEGQCiQGQaQLQaALNgIAQagLQaALNgIAQaALJAgL3gEBA38jC0EEayQLAkAjC0GcDUgNACMLIgEgADYCACABQQhrJAsjC0GcDUgNACMLIgFCADcDAAJ/IAFBoAg2AgQgAUEEayQLIwtBnA1IDQEjC0EANgIAQZwIKAIAQQF2QQF0IgIgAEEUaygCEEEBdkEBdCIBaiIDRQRAIwtBBGokC0HgCAwBCyMLIANBARALIgM2AgAgA0GgCCACEA0gAiADaiAAIAEQDSMLQQRqJAsgAwshACMLIAA2AgAgABABIwtBCGokCyMLQQRqJAsPC0GwjQFB4I0BQQFBARAAAAsgACMHIABBFGsiACgCBEEDcUYEQCAAEAQjA0EBaiQDCwsL1gMTAEGMCAsBPABBmAgLKwEAAAAkAAAAbQBlAHMAcwBhAGcAZQAgAHIAZQBjAGUAaQB2AGUAZAA6ACAAQcwICwEcAEHYCAsBAQBB7AgLATwAQfgICy8BAAAAKAAAAEEAbABsAG8AYwBhAHQAaQBvAG4AIAB0AG8AbwAgAGwAYQByAGcAZQBBrAkLATwAQbgJCycBAAAAIAAAAH4AbABpAGIALwByAHQALwBpAHQAYwBtAHMALgB0AHMAQawKCwE8AEG4CgsrAQAAACQAAABJAG4AZABlAHgAIABvAHUAdAAgAG8AZgAgAHIAYQBuAGcAZQBB7AoLASwAQfgKCxsBAAAAFAAAAH4AbABpAGIALwByAHQALgB0AHMAQbwLCwE8AEHICwslAQAAAB4AAAB+AGwAaQBiAC8AcgB0AC8AdABsAHMAZgAuAHQAcwBB/AsLATwAQYgMCzEBAAAAKgAAAE8AYgBqAGUAYwB0ACAAYQBsAHIAZQBhAGQAeQAgAHAAaQBuAG4AZQBkAEG8DAsBPABByAwLLwEAAAAoAAAATwBiAGoAZQBjAHQAIABpAHMAIABuAG8AdAAgAHAAaQBuAG4AZQBkAEGADQsNAwAAACAAAAAAAAAAIAArEHNvdXJjZU1hcHBpbmdVUkwZLi9yZWNlaXZlbWVzc2FnZS53YXNtLm1hcA==\"\n    const address = create_sc(bytes);\n    send_message(address, \"receive\", 1, 1, 20, 20, 100_000, 1, 100, \"hello my good friend!\");\n    print(\"receiver created and message sent\")\n}\n","@external(\"massa\", \"assembly_script_print\")\nexport declare function assembly_script_print(message: string): void\n@external(\"massa\", \"assembly_script_call\")\nexport declare function assembly_script_call(address: string, func: string, param: string, call_coins: i64): string\n@external(\"massa\", \"assembly_script_get_remaining_gas\")\nexport declare function assembly_script_get_remaining_gas(): u64\n@external(\"massa\", \"assembly_script_create_sc\")\nexport declare function assembly_script_create_sc(bytecode: string): string\n@external(\"massa\", \"assembly_script_set_data\")\nexport declare function assembly_script_set_data(key: string, value: string): void;\n@external(\"massa\", \"assembly_script_set_data_for\")\nexport declare function assembly_script_set_data_for(address: string, key: string, value: string): void;\n@external(\"massa\", \"assembly_script_get_data\")\nexport declare function assembly_script_get_data(key: string): string;\n@external(\"massa\", \"assembly_script_get_data_for\")\nexport declare function assembly_script_get_data_for(address: string, key: string): string;\n@external(\"massa\", \"assembly_script_has_data\")\nexport declare function assembly_script_has_data(key: string): bool;\n@external(\"massa\", \"assembly_script_has_data_for\")\nexport declare function assembly_script_has_data_for(address: string, key: string): bool;\n@external(\"massa\", \"assembly_script_get_owned_addresses\")\nexport declare function assembly_script_get_owned_addresses(): string;\n@external(\"massa\", \"assembly_script_get_call_stack\")\nexport declare function assembly_script_get_call_stack(): string;\n@external(\"massa\", \"assembly_script_generate_event\")\nexport declare function assembly_script_generate_event(event: string): void;\n@external(\"massa\", \"assembly_script_transfer_coins\")\nexport declare function assembly_script_transfer_coins(to_address: string, raw_amount: u64): void;\n@external(\"massa\", \"assembly_script_transfer_coins_for\")\nexport declare function assembly_script_transfer_coins_for(from_address: string, to_address: string, raw_amount: u64): void;\n@external(\"massa\", \"assembly_script_get_balance\")\nexport declare function assembly_script_get_balance(): u64;\n@external(\"massa\", \"assembly_script_get_balance_for\")\nexport declare function assembly_script_get_balance_for(address: string): u64;\n@external(\"massa\", \"assembly_script_get_call_coins\")\nexport declare function assembly_script_get_call_coins(): u64;\n@external(\"massa\", \"assembly_script_hash\")\nexport declare function assembly_script_hash(data: string): string;\n@external(\"massa\", \"assembly_script_signature_verify\")\nexport declare function assembly_script_signature_verify(data: string, signature: string, public_key: string): bool;\n@external(\"massa\", \"assembly_script_address_from_public_key\")\nexport declare function assembly_script_address_from_public_key(public_key: string): string;\n@external(\"massa\", \"assembly_script_get_time\")\nexport declare function assembly_script_get_time(): u64;\n@external(\"massa\", \"assembly_script_unsafe_random\")\nexport declare function assembly_script_unsafe_random(): i64;\n@external(\"massa\", \"assembly_script_send_message\")\nexport declare function assembly_script_send_message(target_address: string, target_handler: string, validity_start_period: u64, validity_start_thread: u8, validity_end_period: u64, validity_end_thread: u8, max_gas: u64, gas_price: u64, raw_coins: u64, data: string): void;\n\n/**\n * Prints in the node logs\n *\n * @param message Message string\n */\nexport function print(message: string): void {\n    assembly_script_print(message);\n}\n\n/**\n * Retreive a module in the ledger at the given address and call a function\n *\n * @param address Address hash in format string\n * @param func Function name exported in the module\n * @param param String input parameters\n * @param param i64 call coins\n * @returns String output of the function called\n */\nexport function call(address: string, func: string, param: string, call_coins: i64): string {\n    return assembly_script_call(address, func, param, call_coins);\n}\n\n\n/**\n * Take a base64 string representing the module binary and create an entry in\n * the ledger.\n *\n * The context allow you to write in this smart contract while you're executing\n * the current bytecode.\n *\n * @param bytecode string base64 of the ledger\n * @returns Created entry address\n */\nexport function create_sc(bytecode: string): string {\n    return assembly_script_create_sc(bytecode);\n}\n\nexport namespace Storage {\n    /**\n     * Set data in the creator of operation ledger entry database.\n     *\n     * ```js\n     * // Each ledger entry contains this object.\n     * {\n     *  sce_balance, // Amount\n     *  database, // HashMap<Hash, Vec<u8>>\n     *  program_data, // Vec<u8>\n     * }\n     * ```\n     * @param key key address of the data\n     * @param value value to put in the DB\n     */\n    export function set_data(key: string, value: string): void {\n        assembly_script_set_data(key, value);\n    }\n\n    /**\n     * Set data in the creator of operation ledger entry database in a specified address. \\\n     * You won't be able to insert a value if you're not the direct creator of the entry \\\n     * or the owner of the address.\n     *\n     * ```js\n     * // Each ledger entry contains this object.\n     * {\n     *  sce_balance, // Amount\n     *  database, // HashMap<Hash, Vec<u8>>\n     *  program_data, // Vec<u8>\n     * }\n     * ```\n     * @param address address of a smart contract or user hash\n     * @param key key address of the data\n     * @param value value to put in the DB\n     */\n    export function set_data_for(address: string, key: string, value: string): void {\n        assembly_script_set_data_for(address, key, value);\n    }\n\n    /**\n     * Get data in the creator of operation ledger entry database.\n     *\n     * ```js\n     * // Each ledger entry contains this object.\n     * {\n     *  sce_balance, // Amount\n     *  database, // HashMap<Hash, Vec<u8>>\n     *  program_data, // Vec<u8>\n     * }\n     * ```\n     * @param key key address of the data\n     * @param value value if the key\n     */\n    export function get_data(key: string): string {\n        return assembly_script_get_data(key);\n    }\n\n    /**\n     * Get data in the creator of operation ledger entry database in a specified address.\n     *\n     * ```js\n     * // Each ledger entry contains this object.\n     * {\n     *  sce_balance, // Amount\n     *  database, // HashMap<Hash, Vec<u8>>\n     *  program_data, // Vec<u8>\n     * }\n     * ```\n     * @param address address of a smart contract or user hash\n     * @param key key address of the data\n     * @param value value if the key\n     */\n    export function get_data_for(address: string, key: string): string {\n        return assembly_script_get_data_for(address, key);\n    }\n\n    /**\n     * Checks whether an entry exists in the caller's datastore.\n     *\n     * @param key key of the data (will be hashed internally)\n     * @returns true if the key was found, false otherwise\n     */\n    export function has_data(key: string): bool {\n        return assembly_script_has_data(key);\n    }\n\n    /**\n     * Checks whether an entry exists in the datastore of an arbitrary address.\n     *\n     * @param address target address\n     * @param key key of the data (will be hashed internally)\n     * @returns true if the key was found, false otherwise\n     */\n    export function has_data_for(address: string, key: string): bool {\n        return assembly_script_has_data_for(address, key);\n    }\n\n    /**\n     *  Returns an entry from the caller's datastore or a default value if not found\n     *\n     * @param address target address\n     * @param key key of the data (will be hashed internally)\n     * @param default_value default value if not found\n     * @returns found string value or default string\n     */\n    export function get_data_or_default(key: string, default_value: string): string {\n        if (has_data(key)) {\n            return get_data(key);\n        }\n        return default_value;\n    }\n\n    /**\n     *  Returns an entry from an address' datastore or a default value if not found\n     *\n     * @param address target address\n     * @param key key of the data (will be hashed internally)\n     * @param default_value default value if not found\n     * @returns found string value or default string\n     */\n    export function get_data_or_default_for(address: string, key: string, default_value: string): string {\n        if (has_data_for(address, key)) {\n            return get_data_for(address, key);\n        }\n        return default_value;\n    }\n}\n\nexport namespace Context {\n\n\n    /**\n     * Get context current owned addresses.\n     *\n     * You can check your own address or check the addresses of the smart contract you've created during the current execution.\n     *\n     * @returns JSON formated list of addresses containing the owned addresses\n     */\n    export function get_owned_addresses(): string {\n        return assembly_script_get_owned_addresses();\n    }\n\n    /**\n     * Get context current call stack\n     *\n     * The call stack is stack of called module. You can look all previous \\\n     * addresses since the address of the operation sender.\n     *\n     * @returns JSON formated list of addresses containing the call stack\n     */\n    export function get_call_stack(): string {\n        return assembly_script_get_call_stack();\n    }\n\n    /**\n    * Gets the amount of coins transferred in the current call\n    *\n    * @returns Raw amount of coins (in elementary nits)\n    */\n    export function get_call_coins(): u64 {\n        return assembly_script_get_call_coins();\n    }\n\n\n    /**\n     * Gets the slot unix timestamp in milliseconds\n     *\n     * @returns unix timestamp in milliseconds\n     */\n    export function get_time(): u64 {\n        return assembly_script_get_time();\n    }\n\n\n    /**\n     * Return the remaining gas available\n     * @returns Gas available\n     */\n    export function get_remaining_gas(): u64 {\n        return assembly_script_get_remaining_gas();\n    }\n\n}\n\n/**\n * Generates an event\n *\n * @param message String version of the event\n */\nexport function generate_event(event: string): void {\n    assembly_script_generate_event(event);\n}\n\n/**\n * Transfer SCE coins from the current address to to_address\n *\n * @param to_address Destination address hash in format string\n * @param raw_amount Raw amount (in elementary units)\n */\nexport function transfer_coins(to_address: string, raw_amount: u64): void {\n    return assembly_script_transfer_coins(to_address, raw_amount);\n}\n\n/**\n * Transfer SCE coins from from_address to to_address\n *\n * @param from_address Source address hash in format string\n * @param to_address Destination address hash in format string\n * @param raw_amount Raw amount (in elementary units)\n */\nexport function transfer_coins_for(from_address: string, to_address: string, raw_amount: u64): void {\n    return assembly_script_transfer_coins_for(from_address, to_address, raw_amount);\n}\n\n/**\n * Gets the balance of the current address\n *\n * @returns The raw balance of the address (in elementary nits)\n */\nexport function get_balance(): u64 {\n    return assembly_script_get_balance();\n}\n\n\n/**\n * Gets the balance of the specified address\n *\n * @param address Address hash in format string\n * @returns The raw balance of the address (in elementary nits)\n */\nexport function get_balance_for(address: string): u64 {\n    return assembly_script_get_balance_for(address);\n}\n\n/**\n * Hash data and return the base58-encoded hash\n *\n * @param data Data to hash\n */\nexport function hash(data: string): string {\n    return assembly_script_hash(data);\n}\n\n/**\n * Hash data and return the base58-encoded hash\n *\n * @param data Data that was signed\n * @param signature base58check signature\n * @param public_key base58check public key\n * @returns true if verification suceeded, false otherwise\n */\nexport function signature_verify(data: string, signature: string, public_key: string): bool {\n    return assembly_script_signature_verify(data, signature, public_key);\n}\n\n/**\n * Converts a public key to an address\n *\n * @param public_key Base58check public key\n * @returns the resulting address\n */\nexport function address_from_public_key(data: string): string {\n    return assembly_script_address_from_public_key(data);\n}\n\n/**\n * Gets an unsafe random i64 (all bits random)\n * This function is unsafe because the random draws can be predicted and manipulated by attackers.\n *\n * @returns random signed 64bit integer\n */\nexport function unsafe_random(): i64 {\n    return assembly_script_unsafe_random();\n}\n\n/**\n * Sends an async message\n *\n * @param target_address Destination address hash in format string\n * @param target_handler Name of the message handling function\n * @param validity_start_period Period of the validity start slot\n * @param validity_start_thread Thread of the validity start slot\n * @param validity_end_period Period of the validity end slot\n * @param validity_end_thread Thread of the validity end slot\n * @param max_gas Maximum gas for the message execution\n * @param gas_price Price of one gas unit\n * @param coins Coins of the sender\n * @param data Message data\n * @returns Nothing\n */\nexport function send_message(target_address: string, target_handler: string, validity_start_period: u64, validity_start_thread: u8, validity_end_period: u64, validity_end_thread: u8, max_gas: u64, gas_price: u64, raw_coins: u64, data: string): void {\n    return assembly_script_send_message(target_address, target_handler, validity_start_period, validity_start_thread, validity_end_period, validity_end_thread, max_gas, gas_price, raw_coins, data);\n}\n\n/**\n * Empty function that can be replaced before the compilation with\n * include_base64.js.\n *\n * ```bash\n * node massa_tools/include_base64.js assembly/create_sc.ts && asc assembly/create_sc.m.ts --target release --exportRuntime\n * ```\n * @param _path\n */\nexport function include_base64(_path: string): string {\n    /* NOT IMPLEMENTED HERE */\n    abort('Please use massa tool *include_base64* compilation')\n}\n","// Common error messages for use across the standard library. Keeping error messages compact\n// and reusing them where possible ensures minimal static data in binaries.\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INDEXOUTOFRANGE: string = \"Index out of range\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_VALUEOUTOFRANGE: string = \"Value out of range\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INVALIDLENGTH: string = \"Invalid length\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ILLEGALGENTYPE: string = \"Illegal generic type\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_EMPTYARRAY: string = \"Array is empty\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_HOLEYARRAY: string = \"Element type must be nullable if array is holey\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_NOTIMPLEMENTED: string = \"Not implemented\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_KEYNOTFOUND: string = \"Key does not exist\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ALLOCATION_TOO_LARGE: string = \"Allocation too large\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ALREADY_PINNED: string = \"Object already pinned\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_NOT_PINNED: string = \"Object is not pinned\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_URI_MALFORMED: string = \"URI malformed\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INVALIDDATE: string = \"Invalid Date\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_UNPAIRED_SURROGATE: string = \"Unpaired surrogate\";\n","// This file is shared with the compiler and must remain portable\n\n/** Runtime types. */\nexport enum Runtime {\n  /** Simple bump allocator without GC. */\n  Stub = 0,\n  /** Stop the world semi-automatic GC. */\n  Minimal = 1,\n  /** incremental GC. */\n  Incremental = 2,\n}\n","import { Typeinfo, TypeinfoFlags } from \"./shared/typeinfo\";\nimport { E_INDEXOUTOFRANGE } from \"./util/error\";\nimport { OBJECT, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { ArrayBufferView } from \"./arraybuffer\";\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __rtti_base: usize;\n\n// @ts-ignore: decorator\n@builtin @unsafe\nexport declare function __visit_globals(cookie: u32): void;\n\n// @ts-ignore: decorator\n@builtin @unsafe\nexport declare function __visit_members(ref: usize, cookie: u32): void;\n\n// @ts-ignore: decorator\n@unsafe\nexport function __typeinfo(id: u32): TypeinfoFlags {\n  var ptr = __rtti_base;\n  if (id > load<u32>(ptr)) throw new Error(E_INDEXOUTOFRANGE);\n  return changetype<Typeinfo>(ptr + sizeof<u32>() + id * offsetof<Typeinfo>()).flags;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __instanceof(ptr: usize, classId: u32): bool { // keyword\n  var id = changetype<OBJECT>(ptr - TOTAL_OVERHEAD).rtId;\n  var rttiBase = __rtti_base;\n  if (id <= load<u32>(rttiBase)) {\n    do if (id == classId) return true;\n    while (id = changetype<Typeinfo>(rttiBase + sizeof<u32>() + id * offsetof<Typeinfo>()).base);\n  }\n  return false;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __newBuffer(size: usize, id: u32, data: usize = 0): usize {\n  var buffer = __new(size, id);\n  if (data) memory.copy(buffer, data, size);\n  return buffer;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __newArray(length: i32, alignLog2: usize, id: u32, data: usize = 0): usize {\n  var bufferSize = <usize>length << alignLog2;\n  // make sure `buffer` is tracked by the shadow stack\n  var buffer = changetype<ArrayBuffer>(__newBuffer(bufferSize, idof<ArrayBuffer>(), data));\n  // ...since allocating the array may trigger GC steps\n  var array = __new(offsetof<i32[]>(), id);\n  store<usize>(array, changetype<usize>(buffer), offsetof<ArrayBufferView>(\"buffer\"));\n  __link(array, changetype<usize>(buffer), false);\n  store<usize>(array, changetype<usize>(buffer), offsetof<ArrayBufferView>(\"dataStart\"));\n  store<i32>(array, bufferSize, offsetof<ArrayBufferView>(\"byteLength\"));\n  store<i32>(array, length, offsetof<i32[]>(\"length_\"));\n  return array;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nfunction __tostack(ptr: usize): usize { // eslint-disable-line\n  return ptr;\n}\n\n// These are provided by the respective implementation, included as another entry file by asc:\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __alloc(size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __realloc(ptr: usize, size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __free(ptr: usize): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __new(size: usize, id: u32): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __renew(ptr: usize, size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __collect(): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __visit(ptr: usize, cookie: u32): void;\n","import { memcmp, memmove, memset } from \"./util/memory\";\nimport { E_NOTIMPLEMENTED } from \"./util/error\";\n\n/** Memory manager interface. */\nexport namespace memory {\n\n  /** Gets the size of the memory in pages. */\n  // @ts-ignore: decorator\n  @builtin\n  export declare function size(): i32;\n\n  /** Grows the memory by the given size in pages and returns the previous size in pages. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function grow(pages: i32): i32;\n\n  /** Fills a section in memory with the specified byte value. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function fill(dst: usize, c: u8, n: usize): void {\n    memset(dst, c, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  /** Copies a section of memory to another. Has move semantics. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function copy(dst: usize, src: usize, n: usize): void {\n    memmove(dst, src, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  /** Initializes a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Drops a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function drop(segmentIndex: u32): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Repeats a section of memory at a specific address. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function repeat(dst: usize, src: usize, srcLength: usize, count: usize): void {\n    var index: usize = 0;\n    var total = srcLength * count;\n    while (index < total) {\n      memory.copy(dst + index, src, srcLength);\n      index += srcLength;\n    }\n  }\n\n  /** Compares a section of memory to another. */\n  // @ts-ignore: decorator\n  @inline\n  export function compare(vl: usize, vr: usize, n: usize): i32 {\n    return memcmp(vl, vr, n);\n  }\n\n  /** Gets a pointer to a static chunk of memory of the given size. */\n  // @ts-ignore: decorator\n  @builtin\n  export declare function data<T>(size: T, align?: i32): usize;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __data_end: usize;\n\n// @ts-ignore: decorator\n@builtin\nexport declare var __stack_pointer: usize;\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __heap_base: usize;\n\n/** Heap memory interface. */\nexport namespace heap {\n\n  /** Allocates a chunk of memory of at least the specified size. */\n  // @ts-ignore: decorator\n  @unsafe export function alloc(size: usize): usize {\n    return __alloc(size);\n  }\n\n  /** Reallocates a chunk of memory to have at least the specified size. */\n  // @ts-ignore: decorator\n  @unsafe export function realloc(ptr: usize, size: usize): usize {\n    return __realloc(ptr, size);\n  }\n\n  /** Frees a chunk of memory. Does hardly anything (most recent block only) with the stub runtime. */\n  // @ts-ignore: decorator\n  @unsafe export function free(ptr: usize): void {\n    __free(ptr);\n  }\n\n  /** Dangerously resets the entire heap. Specific to the stub runtime. */\n  // @ts-ignore: decorator\n  @unsafe export function reset(): void {\n    if (isDefined(__reset)) {\n      __reset();\n    } else {\n      throw new Error(E_NOTIMPLEMENTED);\n    }\n  }\n}\n","export function memcpy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memcpy.c\n  var w: u32, x: u32;\n\n  // copy 1 byte each until src is aligned to 4 bytes\n  while (n && (src & 3)) {\n    store<u8>(dest++, load<u8>(src++));\n    n--;\n  }\n\n  // if dst is aligned to 4 bytes as well, copy 4 bytes each\n  if ((dest & 3) == 0) {\n    while (n >= 16) {\n      store<u32>(dest     , load<u32>(src     ));\n      store<u32>(dest +  4, load<u32>(src +  4));\n      store<u32>(dest +  8, load<u32>(src +  8));\n      store<u32>(dest + 12, load<u32>(src + 12));\n      src += 16; dest += 16; n -= 16;\n    }\n    if (n & 8) {\n      store<u32>(dest    , load<u32>(src    ));\n      store<u32>(dest + 4, load<u32>(src + 4));\n      dest += 8; src += 8;\n    }\n    if (n & 4) {\n      store<u32>(dest, load<u32>(src));\n      dest += 4; src += 4;\n    }\n    if (n & 2) { // drop to 2 bytes each\n      store<u16>(dest, load<u16>(src));\n      dest += 2; src += 2;\n    }\n    if (n & 1) { // drop to 1 byte\n      store<u8>(dest++, load<u8>(src++));\n    }\n    return;\n  }\n\n  // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\n  // doing shifts if faster when copying enough bytes (here: 32 or more)\n  if (n >= 32) {\n    switch (<u32>dest & 3) {\n      // known to be != 0\n      case 1: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 3;\n        while (n >= 17) {\n          x = load<u32>(src + 1);\n          store<u32>(dest, w >> 24 | x << 8);\n          w = load<u32>(src + 5);\n          store<u32>(dest + 4, x >> 24 | w << 8);\n          x = load<u32>(src + 9);\n          store<u32>(dest + 8, w >> 24 | x << 8);\n          w = load<u32>(src + 13);\n          store<u32>(dest + 12, x >> 24 | w << 8);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 2: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 2;\n        while (n >= 18) {\n          x = load<u32>(src + 2);\n          store<u32>(dest, w >> 16 | x << 16);\n          w = load<u32>(src + 6);\n          store<u32>(dest + 4, x >> 16 | w << 16);\n          x = load<u32>(src + 10);\n          store<u32>(dest + 8, w >> 16 | x << 16);\n          w = load<u32>(src + 14);\n          store<u32>(dest + 12, x >> 16 | w << 16);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 3: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        n -= 1;\n        while (n >= 19) {\n          x = load<u32>(src + 3);\n          store<u32>(dest, w >> 8 | x << 24);\n          w = load<u32>(src + 7);\n          store<u32>(dest + 4, x >> 8 | w << 24);\n          x = load<u32>(src + 11);\n          store<u32>(dest + 8, w >> 8 | x << 24);\n          w = load<u32>(src + 15);\n          store<u32>(dest + 12, x >> 8 | w << 24);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n    }\n  }\n\n  // copy remaining bytes one by one\n  if (n & 16) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 8) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 4) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 2) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 1) {\n    store<u8>(dest++, load<u8>(src++));\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memmove(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\n  if (dest === src) return;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (src - dest - n <= -(n << 1)) {\n      memcpy(dest, src, n);\n      return;\n    }\n  }\n  if (dest < src) {\n    if (ASC_SHRINK_LEVEL < 2) {\n      if ((src & 7) == (dest & 7)) {\n        while (dest & 7) {\n          if (!n) return;\n          --n;\n          store<u8>(dest++, load<u8>(src++));\n        }\n        while (n >= 8) {\n          store<u64>(dest, load<u64>(src));\n          n    -= 8;\n          dest += 8;\n          src  += 8;\n        }\n      }\n    }\n    while (n) {\n      store<u8>(dest++, load<u8>(src++));\n      --n;\n    }\n  } else {\n    if (ASC_SHRINK_LEVEL < 2) {\n      if ((src & 7) == (dest & 7)) {\n        while ((dest + n) & 7) {\n          if (!n) return;\n          store<u8>(dest + --n, load<u8>(src + n));\n        }\n        while (n >= 8) {\n          n -= 8;\n          store<u64>(dest + n, load<u64>(src + n));\n        }\n      }\n    }\n    while (n) {\n      store<u8>(dest + --n, load<u8>(src + n));\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memset(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\n  if (ASC_SHRINK_LEVEL > 1) {\n    while (n) {\n      store<u8>(dest++, c);\n      --n;\n    }\n  } else {\n    // fill head and tail with minimal branching\n    if (!n) return;\n    let dend = dest + n;\n    store<u8>(dest, c);\n    store<u8>(dend - 1, c);\n    if (n <= 2) return;\n    store<u8>(dest, c, 1);\n    store<u8>(dest, c, 2);\n    store<u8>(dend - 2, c);\n    store<u8>(dend - 3, c);\n    if (n <= 6) return;\n    store<u8>(dest, c, 3);\n    store<u8>(dend - 4, c);\n    if (n <= 8) return;\n\n    // advance pointer to align it at 4-byte boundary\n    let k: usize = -dest & 3;\n    dest += k;\n    n -= k;\n    n &= -4;\n\n    let c32: u32 = <u32>-1 / 255 * c;\n\n    // fill head/tail up to 28 bytes each in preparation\n    dend = dest + n;\n    store<u32>(dest, c32);\n    store<u32>(dend - 4, c32);\n    if (n <= 8) return;\n    store<u32>(dest, c32, 4);\n    store<u32>(dest, c32, 8);\n    store<u32>(dend - 12, c32);\n    store<u32>(dend - 8, c32);\n    if (n <= 24) return;\n    store<u32>(dest, c32, 12);\n    store<u32>(dest, c32, 16);\n    store<u32>(dest, c32, 20);\n    store<u32>(dest, c32, 24);\n    store<u32>(dend - 28, c32);\n    store<u32>(dend - 24, c32);\n    store<u32>(dend - 20, c32);\n    store<u32>(dend - 16, c32);\n\n    // align to a multiple of 8\n    k = 24 + (dest & 4);\n    dest += k;\n    n -= k;\n\n    // copy 32 bytes each\n    let c64: u64 = <u64>c32 | (<u64>c32 << 32);\n    while (n >= 32) {\n      store<u64>(dest, c64);\n      store<u64>(dest, c64, 8);\n      store<u64>(dest, c64, 16);\n      store<u64>(dest, c64, 24);\n      n -= 32;\n      dest += 32;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memcmp(vl: usize, vr: usize, n: usize): i32 {\n  if (vl == vr) return 0;\n  if (ASC_SHRINK_LEVEL < 2) {\n    if ((vl & 7) == (vr & 7)) {\n      while (vl & 7) {\n        if (!n) return 0;\n        let a = <i32>load<u8>(vl);\n        let b = <i32>load<u8>(vr);\n        if (a != b) return a - b;\n        n--; vl++; vr++;\n      }\n      while (n >= 8) {\n        if (load<u64>(vl) != load<u64>(vr)) break;\n        vl += 8;\n        vr += 8;\n        n  -= 8;\n      }\n    }\n  }\n  while (n--) {\n    let a = <i32>load<u8>(vl);\n    let b = <i32>load<u8>(vr);\n    if (a != b) return a - b;\n    vl++; vr++;\n  }\n  return 0;\n}\n"]}