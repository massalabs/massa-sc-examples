import { sumHelper } from "./sumHelper";
import {
    Client,
    IClientConfig,
    IEventFilter,
    IProvider,
    ProviderType,
    EventPoller,
    ON_MASSA_EVENT_DATA,
    ON_MASSA_EVENT_ERROR,
    IEvent,
    INodeStatus,
    time,
} from "@massalabs/massa-web3";

/**
 * This interface represents the details of the transaction.
 *
 * @see operationId - The operationId of the Smart Contract call
 */
export interface TransactionDetails {
    operationId: string;
}

/**
 * This interface represents the result of the event poller.
 *
 * @see isError - A boolean indicating wether the Smart Contract call has failed or not
 * @see eventPoller - The eventPoller object
 * @see events - The events emitted by the Smart Contract call
 */
export interface EventPollerResult {
    isError: boolean;
    eventPoller: EventPoller;
    events: IEvent[];
}

/**
 * This interface is used to represents the outputs of the SC call.
 *
 * @see outputs - The outputs of the SC call (optional)
 * @see events - The events emitted by the SC call (optional)
 * @see error - The error message (optional)
 */
export interface OperationOutputs {
    outputs?: any;
    events: IEvent[];
    error: any;
}

const MASSA_EXEC_ERROR = "massa_execution_error";
const OUTPUTS_PREFIX = "Result: ";

/** The following global variable and the next class should be in a dedicated file. */
let callSC: (
    address: string,
    funcName: string,
    binArguments: Uint8Array,
    maxCoin: bigint
) => Promise<TransactionDetails>;

/**
 * This method have been generated by the Massa Proto CLI.
 * It allows you to call the "sum" function of the
 * "AS1XPo4dWpfNuSHYxkg1nQJcHDwq8oM2Kmcd9KHSS7gaHyvqeEUW" Smart Contract.
 *
 * @remarks
 * To work properly, you need to run 'npm install @protobuf-ts/plugin' in your project folder.
 * Otherwise, this caller will not work.
 *
 * @param {bigint} a -
 * @param {bigint} b -
 *
 * @returns {Promise<OperationOutputs>} A promise that resolves to an object which contains the outputs and events from the call to sum.
 */
export async function sum(
    a: bigint,
    b: bigint,
    coins: bigint
): Promise<OperationOutputs> {
    // Verify that the given arguments are valid
    if (a < 0)
        throw new Error(
            "Invalid argument: a cannot be negative according to protobuf file."
        );
    if (b < 0)
        throw new Error(
            "Invalid argument: b cannot be negative according to protobuf file."
        );

    // Serialize the arguments
    const serializedArgs = sumHelper.toBinary({
        a: a,
        b: b,
    });

    // Send the operation to the blockchain and retrieve its outputs
    return await extractOutputsAndEvents(
        "AS1XPo4dWpfNuSHYxkg1nQJcHDwq8oM2Kmcd9KHSS7gaHyvqeEUW",
        "sum",
        serializedArgs,
        coins,
        "bigint"
    );
}

async function extractOutputsAndEvents(
    contractAddress: string,
    functionName: string,
    args: Uint8Array,
    coins: bigint,
    returnType: string
): Promise<OperationOutputs> {
    let events: IEvent[] = [];

    // try to call the Smart Contract
    try {
        events = await getEvents(
            (await callSC(
                contractAddress,
                functionName,
                args,
                coins
            )) as TransactionDetails
        );
    } catch (err) {
        // if the call fails, return the error
        return {
            events: events,
            error: err,
        } as OperationOutputs;
    }

    // if the call is successful, retrieve the outputs from the events
    let rawOutput: string | null = null;
    for (let event of events) {
        if (event.data.slice(0, OUTPUTS_PREFIX.length) == OUTPUTS_PREFIX) {
            rawOutput = event.data.slice(OUTPUTS_PREFIX.length);
            // remove the event from the list
            events.splice(events.indexOf(event), 1);
            break;
        }
    }

    // check the output and return the result
    if (rawOutput === null && returnType !== "void") {
        return {
            events: events,
            error: "No outputs found. Expected type: " + returnType,
        } as OperationOutputs;
    }
    if (rawOutput === null && returnType === "void") {
        return {
            events: events,
        } as OperationOutputs;
    }
    if (rawOutput !== null && returnType !== "void") {
        // try to deserialize the outputs
        let output: Uint8Array = new Uint8Array(0);
        let deserializedOutput = null;
        try {
            output = rawOutput
                .slice(1, -1)
                .split(",")
                .map((s) => parseInt(s)) as unknown as Uint8Array;
            deserializedOutput = sumHelper.fromBinary(output);
        } catch (err) {
            return {
                events: events,
                error: "Error while deserializing the outputs: " + err,
            } as OperationOutputs;
        }
        return {
            outputs: output,
            events: events,
        } as OperationOutputs;
    }
    return {
        events: events,
        error: "Unexpected error",
    } as OperationOutputs;
}

/**
 * This method have been generated by the Massa Proto CLI.
 * It sets up all the objects needed to poll the events generated by the "sum" function.
 *
 * @param {TransactionDetails} txDetails - An object containing the operationId of SC call.
 *
 * @returns {Promise<EventPollerResult>} An object containing the eventPoller and the events.
 */
async function getEvents(txDetails: TransactionDetails): Promise<IEvent[]> {
    const opId = txDetails.operationId;

    // setup the providers
    const providerPub: IProvider = {
        url: "https://buildnet.massa.net/api/v2:33035",
        type: ProviderType.PUBLIC,
    };
    const providerPriv: IProvider = {
        url: "https://buildnet.massa.net/api/v2:33035",
        type: ProviderType.PRIVATE,
    }; // we don't need it here but a private provider is required by the BaseClient object

    // setup the client config
    const clientConfig: IClientConfig = {
        providers: [providerPub, providerPriv],
        periodOffset: null,
    };
    // setup the client
    const client = new Client(clientConfig);

    // async poll events in the background for the given opId
    const { isError, eventPoller, events }: EventPollerResult =
        await time.withTimeoutRejection<EventPollerResult>(
            pollAsyncEvents(client, opId),
            20000
        );

    // stop polling
    eventPoller.stopPolling();

    // if errors, don't await finalization
    if (isError) {
        throw new Error(
            "Massa Operation Error: " + JSON.stringify(events, null, 4)
        );
    }

    return events;
}

/**
 * Asynchronously polls events from the chain for a given operationId
 *
 * @param web3Client - an initialized web3 client
 * @param opId - the operation id whose events are to be polled
 *
 * @throws in case of a timeout or massa execution error
 *
 * @returns A promise that resolves to an 'EventPollerResult' which contains the results or an error
 *
 */
const pollAsyncEvents = async (
    web3Client: Client,
    opId: string
): Promise<EventPollerResult> => {
    console.log("Operation Id: ", opId);
    console.log("Polling for events...");
    // determine the last slot
    let nodeStatusInfo: INodeStatus | null | undefined = await web3Client
        .publicApi()
        .getNodeStatus();

    // set the events filter
    const eventsFilter = {
        start: {
            period: nodeStatusInfo.last_slot.period - 2,
            thread: nodeStatusInfo.last_slot.thread,
        }, // last slot - 2 to avoid missing events
        end: null,
        original_caller_address: null,
        original_operation_id: opId,
        emitter_address: null,
        is_final: false,
    } as IEventFilter;

    const eventPoller = EventPoller.startEventsPolling(
        eventsFilter,
        1000,
        web3Client
    );

    return new Promise((resolve, reject) => {
        eventPoller.on(ON_MASSA_EVENT_DATA, (events: Array<IEvent>) => {
            let errorEvents: IEvent[] = events.filter((e) =>
                e.data.includes(MASSA_EXEC_ERROR)
            );
            if (errorEvents.length > 0) {
                return resolve({
                    isError: true,
                    eventPoller,
                    events: errorEvents,
                } as EventPollerResult);
            }

            if (events.length > 0) {
                return resolve({
                    isError: false,
                    eventPoller,
                    events,
                } as EventPollerResult);
            } else {
                console.log("No events have been emitted");
            }
        });
        eventPoller.on(ON_MASSA_EVENT_ERROR, (error: Error) => {
            console.log("Event Data Error:", error);
            return reject(error);
        });
    });
};
