/*****************HELPER GENERATED BY MASSA-PROTO-CLI*****************/

import {
  Client,
  IClientConfig,
  IEventFilter,
  IProvider,
  ProviderType,
  EventPoller,
  ON_MASSA_EVENT_DATA,
  ON_MASSA_EVENT_ERROR,
  IEvent,
  INodeStatus,
  withTimeoutRejection,
} from "@massalabs/massa-web3";

export const MASSA_EXEC_ERROR = 'massa_execution_error';

/**
 * This interface represents the result of the event poller.
 *
 * @see isError - A boolean indicating wether the Smart Contract call has failed or not
 * @see eventPoller - The eventPoller object
 * @see events - The events emitted by the Smart Contract call
 */
export interface EventPollerResult {
  isError: boolean;
  eventPoller: EventPoller;
  events: IEvent[];
}

/**
 * This interface represents the details of the transaction.
 *
 * @see operationId - The operationId of the Smart Contract call
 */
export interface TransactionDetails {
  operationId: string;
}
/**
 * This method have been generated by the Massa Proto CLI.
 * It sets up all the objects needed to poll the events generated by a smart contract function.
 *
 * @param {TransactionDetails} txDetails - An object containing the operationId of SC call.
 * @param {string} nodeUrl - The url of the node to connect to.
 *
 * @returns {Promise<EventPollerResult>} An object containing the eventPoller and the events.
 */
export async function getEvents(txDetails: TransactionDetails, nodeUrl: string): Promise<IEvent[]>{
  const opId = txDetails.operationId;

  // setup the providers
  const providerPub: IProvider = {
    url: nodeUrl,
    type: ProviderType.PUBLIC,
  };

  // setup the client config
  const clientConfig: IClientConfig = {
    providers: [providerPub],
    periodOffset: null,
  };
  // setup the client
  const client = new Client(clientConfig);

  // async poll events in the background for the given opId
  const { isError, eventPoller, events }: EventPollerResult =
    await withTimeoutRejection<EventPollerResult>(
      pollAsyncEvents(client, opId),
      20000,
    );

  // stop polling
  eventPoller.stopPolling();

  // if errors, don't await finalization
  if (isError) {
    throw new Error(
      'Massa Operation Error: ' + JSON.stringify(events, null, 4),
    );
  }

  return events;
}

/**
 * Asynchronously polls events from the chain for a given operationId
 *
 * @param web3Client - an initialized web3 client
 * @param opId - the operation id whose events are to be polled
 *
 * @throws in case of a timeout or massa execution error
 *
 * @returns A promise that resolves to an 'EventPollerResult'
 *
 */
const pollAsyncEvents = async (
  web3Client: Client,
  opId: string,
): Promise<EventPollerResult> => {
  console.log('Operation Id: ', opId);
  console.log('Polling for events...');
  // determine the last slot
  let nodeStatusInfo: INodeStatus | null | undefined = await web3Client
    .publicApi()
    .getNodeStatus();

  // set the events filter
  const eventsFilter = {
    start: { period: nodeStatusInfo.last_slot.period - 2, thread: nodeStatusInfo.last_slot.thread }, // last slot - 2 to avoid missing events
    end: null,
    original_caller_address: null,
    original_operation_id: opId,
    emitter_address: null,
    is_final: false,
  } as IEventFilter;

  const eventPoller = EventPoller.startEventsPolling(
    eventsFilter,
    1000,
    web3Client,
  );

  return new Promise((resolve, reject) => {
    eventPoller.on(ON_MASSA_EVENT_DATA, (events: Array<IEvent>) => {
      let errorEvents: IEvent[] = events.filter((e) =>
        e.data.includes(MASSA_EXEC_ERROR),
      );
      if (errorEvents.length > 0) {
        return resolve({
          isError: true,
          eventPoller,
          events: errorEvents,
        } as EventPollerResult);
      }

      if (events.length > 0) {
        return resolve({
          isError: false,
          eventPoller,
          events,
        } as EventPollerResult);
      } else {
        console.log('No events have been emitted');
      }
    });
    eventPoller.on(ON_MASSA_EVENT_ERROR, (error: Error) => {
      console.log('Event Data Error:', error);
      return reject(error);
    });
  });
};
